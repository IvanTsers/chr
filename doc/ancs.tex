\nwfilename{}\nwbegindocs{0}\nwenddocs{}\nwbegindocs{1}\nwdocspar% ===> this file was generated automatically by noweave --- better not edit it
\section{Implementation}
Package \ty{ancs} provides functions for finding anchors and
processing homologies.
\nwenddocs{}\nwbegincode{2}\sublabel{NW0-17BZZK-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-17BZZK-1}}}\moddef{ancs.go~{\nwtagstyle{}\subpageref{NW0-17BZZK-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
package ancs
import (
          \LA{}Imports~{\nwtagstyle{}\subpageref{NW0-YwBeo-1}}\RA{}
)
\LA{}Data structures~{\nwtagstyle{}\subpageref{NW0-O2mca-1}}\RA{}
\LA{}Methods~{\nwtagstyle{}\subpageref{NW0-4RRI1d-1}}\RA{}
\LA{}Functions~{\nwtagstyle{}\subpageref{NW0-1byJZg-1}}\RA{}
\nwnotused{ancs.go}\nwendcode{}\nwbegindocs{3}\nwdocspar
\subsection{Data structure \ty{Seg}}
We declare a custom data type \ty{Seg} for storing segments of the
forward strand of the subject. A segment has a start \ty{s} and a
length \ty{l}.
\nwenddocs{}\nwbegincode{4}\sublabel{NW0-O2mca-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-O2mca-1}}}\moddef{Data structures~{\nwtagstyle{}\subpageref{NW0-O2mca-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-17BZZK-1}}\nwenddeflinemarkup
type Seg struct \{
          s int
          l int
\}
\nwused{\\{NW0-17BZZK-1}}\nwendcode{}\nwbegindocs{5}\nwdocspar
\subsection{Methods}
\subsubsection{\ty{End()}}
Method \ty{End()} returns an end of a segment.
\nwenddocs{}\nwbegincode{6}\sublabel{NW0-4RRI1d-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4RRI1d-1}}}\moddef{Methods~{\nwtagstyle{}\subpageref{NW0-4RRI1d-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-17BZZK-1}}\nwprevnextdefs{\relax}{NW0-4RRI1d-2}\nwenddeflinemarkup
func (seg *Seg) End() int \{
          return seg.s + seg.l - 1
\}
\nwalsodefined{\\{NW0-4RRI1d-2}}\nwused{\\{NW0-17BZZK-1}}\nwendcode{}\nwbegindocs{7}\nwdocspar
\subsubsection{\ty{NewSeg()}}
Constructor method \ty{NewSeg()} returns an empty segment.
\nwenddocs{}\nwbegincode{8}\sublabel{NW0-4RRI1d-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4RRI1d-2}}}\moddef{Methods~{\nwtagstyle{}\subpageref{NW0-4RRI1d-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-17BZZK-1}}\nwprevnextdefs{NW0-4RRI1d-1}{\relax}\nwenddeflinemarkup
func NewSeg() Seg \{
          return Seg\{s:0, l:0\}
\}
\nwused{\\{NW0-17BZZK-1}}\nwendcode{}\nwbegindocs{9}\nwdocspar
\subsection{Functions}
The \ty{ancs} package contains a number of functions.
\nwenddocs{}\nwbegincode{10}\sublabel{NW0-1byJZg-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1byJZg-1}}}\moddef{Functions~{\nwtagstyle{}\subpageref{NW0-1byJZg-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-17BZZK-1}}\nwprevnextdefs{\relax}{NW0-1byJZg-2}\nwenddeflinemarkup
\LA{}SortByStart~{\nwtagstyle{}\subpageref{NW0-2i99Nb-1}}\RA{}
\LA{}MinAncLen~{\nwtagstyle{}\subpageref{NW0-2JjXVq-1}}\RA{}
\LA{}FindHomologies~{\nwtagstyle{}\subpageref{NW0-2wHDRb-1}}\RA{}
\LA{}ReduceOverlaps~{\nwtagstyle{}\subpageref{NW0-1rkFhS-1}}\RA{}
\LA{}TotalSegLen~{\nwtagstyle{}\subpageref{NW0-2soqhP-1}}\RA{}
\LA{}PrintSegSiteRanges~{\nwtagstyle{}\subpageref{NW0-3lf804-1}}\RA{}
\LA{}SegToFasta~{\nwtagstyle{}\subpageref{NW0-1oxqmx-1}}\RA{}
\nwalsodefined{\\{NW0-1byJZg-2}\\{NW0-1byJZg-3}\\{NW0-1byJZg-4}}\nwused{\\{NW0-17BZZK-1}}\nwendcode{}\nwbegindocs{11}\nwdocspar
\subsubsection{\ty{SortByStart()}}
\textbf{\ty{SortByStart()} accepts a slice of segments \ty{s} and sorts the}
\textbf{segments by their start positions in ascending order.}
\nwenddocs{}\nwbegincode{12}\sublabel{NW0-2i99Nb-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2i99Nb-1}}}\moddef{SortByStart~{\nwtagstyle{}\subpageref{NW0-2i99Nb-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1byJZg-1}}\nwenddeflinemarkup
func SortByStart(s []Seg) []Seg \{
        sort.Slice(s, func(i, j int) bool \{
                return s[i].s < s[j].s
        \})
        return s
\}
\nwused{\\{NW0-1byJZg-1}}\nwendcode{}\nwbegindocs{13}\nwdocspar
We import \ty{sort}.
\nwenddocs{}\nwbegincode{14}\sublabel{NW0-YwBeo-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-YwBeo-1}}}\moddef{Imports~{\nwtagstyle{}\subpageref{NW0-YwBeo-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-17BZZK-1}}\nwprevnextdefs{\relax}{NW0-YwBeo-2}\nwenddeflinemarkup
"sort"
\nwalsodefined{\\{NW0-YwBeo-2}\\{NW0-YwBeo-3}\\{NW0-YwBeo-4}}\nwused{\\{NW0-17BZZK-1}}\nwendcode{}\nwbegindocs{15}\nwdocspar
\subsubsection{\ty{MinAncLen()}}
An anchor is a unique non-random match. Its non-randomness is defined
by its length. The threshold length, or the minimum anchor length, is
found from the null shustring length distribution for a sequence with
given length and GC content.

\textbf{The function \ty{MinAncLen()} accepts length, GC content of a}
\textbf{sequence, and the threshold probability, and calculates the minimum}
\textbf{anchor length.}
\nwenddocs{}\nwbegincode{16}\sublabel{NW0-2JjXVq-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2JjXVq-1}}}\moddef{MinAncLen~{\nwtagstyle{}\subpageref{NW0-2JjXVq-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1byJZg-1}}\nwenddeflinemarkup
func MinAncLen(l int, g float64, t float64) int \{
          x := 1
          cq := 0.0 
          for cq < t \{
                  x++
                  cq = cq + sus.Prob(l, g, x)
          \}
          return x
\}
\nwused{\\{NW0-1byJZg-1}}\nwendcode{}\nwbegindocs{17}\nwdocspar
We import \ty{sus}.
\nwenddocs{}\nwbegincode{18}\sublabel{NW0-YwBeo-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-YwBeo-2}}}\moddef{Imports~{\nwtagstyle{}\subpageref{NW0-YwBeo-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-17BZZK-1}}\nwprevnextdefs{NW0-YwBeo-1}{NW0-YwBeo-3}\nwenddeflinemarkup
"github.com/evolbioinf/sus"
\nwused{\\{NW0-17BZZK-1}}\nwendcode{}\nwbegindocs{19}\nwdocspar
\subsubsection{\ty{FindHomologies()}}
\textbf{The function \ty{FindHomologies()} accepts a \ty{fasta} query}
\textbf{sequence, an enhanced suffix array and length of the subject sequence,}
\textbf{and the minimum anchor length \ty{a}. The function returns a slice of}
\textbf{segments (homologies) and a bool map of segregation sites.}

We initialize variables to operate with in the search of homologies,
conduct the search, and return its results.
\nwenddocs{}\nwbegincode{20}\sublabel{NW0-2wHDRb-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2wHDRb-1}}}\moddef{FindHomologies~{\nwtagstyle{}\subpageref{NW0-2wHDRb-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1byJZg-1}}\nwenddeflinemarkup
func FindHomologies(
          query *fasta.Sequence,
          e *esa.Esa,
          subjectLen int,
          a int) ([]Seg, map[int]bool) \{
          \LA{}Initialize search~{\nwtagstyle{}\subpageref{NW0-4Uv9uh-1}}\RA{}
          \LA{}Anchor search~{\nwtagstyle{}\subpageref{NW0-36TQWU-1}}\RA{}
          \LA{}Return the output~{\nwtagstyle{}\subpageref{NW0-WYpU7-1}}\RA{}
\}
\nwused{\\{NW0-1byJZg-1}}\nwendcode{}\nwbegindocs{21}\nwdocspar
We import \ty{fasta} and \ty{esa}.
\nwenddocs{}\nwbegincode{22}\sublabel{NW0-YwBeo-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-YwBeo-3}}}\moddef{Imports~{\nwtagstyle{}\subpageref{NW0-YwBeo-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-17BZZK-1}}\nwprevnextdefs{NW0-YwBeo-2}{NW0-YwBeo-4}\nwenddeflinemarkup
"github.com/ivantsers/fasta"
"github.com/evolbioinf/esa"
\nwused{\\{NW0-17BZZK-1}}\nwendcode{}\nwbegindocs{23}\nwdocspar
We declare variables to operate with during the search. These are:
\begin{itemize}
\itemsep0em
\item current and previous positions in the query;
\item current match: its length and start in the subject;
\item previous match: its length, start and end the subject;
\item current segment;
\item a slice of segments to store the output in;
\item a map to store positions of segregation sites (mismatches);
\item an indicator of right anchor;
\item length of a \ty{single strand} of the subject;
\item length of the query.
\end{itemize}

As one might notice, we calculate the full subject's length before
calling \ty{FindHomologies()}, and we calculate the query's length
inside the function. This design is intentional, so the same subject
can be compared to multiple queries.
\nwenddocs{}\nwbegincode{24}\sublabel{NW0-4Uv9uh-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4Uv9uh-1}}}\moddef{Initialize search~{\nwtagstyle{}\subpageref{NW0-4Uv9uh-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wHDRb-1}}\nwenddeflinemarkup
var qc, qp int
var currLen, currStartS int
var prevLen, prevStartS, prevEndS int
var seg Seg
var h []Seg
n := make(map[int]bool)
rightAnchorFound := false
subjectStrandLen := subjectLen/2
queryLen := query.Length()
\nwused{\\{NW0-2wHDRb-1}}\nwendcode{}\nwbegindocs{25}\nwdocspar
We perform anchor search for each prefix in our query. We get a prefix
that starts at the current position and ends at the last byte of the
query. Then we search for a long unique match using the function
\ty{anchorLongMatch()}, which we still have to write.

If such a match is found, we proceed with calculating the end
positions of the previous match in the query and the subject. Then we
analyze the current match and decide, whether the current segment can
be extended with it. If yes, we extend the current segment. If it
cannot be extended and the right anchor is found, we open a new
segment and save the current one in \ty{h}. After these operations, we
remember the current match and jump in the query by at least one
nucleotide (a guaranteed mismatch) before proceeding with the next
prefix.
\nwenddocs{}\nwbegincode{26}\sublabel{NW0-36TQWU-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-36TQWU-1}}}\moddef{Anchor search~{\nwtagstyle{}\subpageref{NW0-36TQWU-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wHDRb-1}}\nwenddeflinemarkup
for qc < queryLen \{
          queryPrefix := query.Data()[qc:queryLen]
          if anchorLongMatch(&currStartS, &currLen,
                  n, a, queryPrefix, e) \{
                  prevEndQ := qp + prevLen
                  prevEndS = prevStartS + prevLen
                  \LA{}Analyze the match~{\nwtagstyle{}\subpageref{NW0-3tpl4q-1}}\RA{}
                  if segCanBeExtended \{
                  \LA{}Extend the current segment~{\nwtagstyle{}\subpageref{NW0-2NrQan-1}}\RA{}
                  \} else \{
                          if rightAnchorFound || prevLen / 2 >= a \{
                                  \LA{}Close the current segment~{\nwtagstyle{}\subpageref{NW0-SRf1j-1}}\RA{}
                          \}
                          \LA{}Open a new segment~{\nwtagstyle{}\subpageref{NW0-1pw3Ak-1}}\RA{}
                  \}
                  \LA{}Remember the current match~{\nwtagstyle{}\subpageref{NW0-1myLcY-1}}\RA{}
          \}
          qc = qc + currLen + 1
          fmt.Println()
\}
//Close the last segment if open:
if rightAnchorFound || prevLen / 2 >= a \{
          if seg.s > subjectStrandLen \{
                  seg.s = subjectLen + 1 - seg.s - seg.l
          \}
          h = append(h, seg)
\}

\nwused{\\{NW0-2wHDRb-1}}\nwendcode{}\nwbegindocs{27}\nwdocspar
\textbf{The function \ty{anchorLongMatch()} accepts pointers to length of the}
current match and its start in the subject, a map of segregation
sites, minimum anchor length, current query prefix, and a pointer to
the subject ESA. The function returns a boolean and updates the start
and the length of the current match.

A match is unique if it starts and ends at the same position in an
ESA. In terms of a suffix tree, a unique match ends on a leaf.
\nwenddocs{}\nwbegincode{28}\sublabel{NW0-1byJZg-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1byJZg-2}}}\moddef{Functions~{\nwtagstyle{}\subpageref{NW0-1byJZg-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-17BZZK-1}}\nwprevnextdefs{NW0-1byJZg-1}{NW0-1byJZg-3}\nwenddeflinemarkup
func anchorLongMatch(
          currStartS, currLen *int,
          n map[int]bool,
          a int,
          queryPrefix []byte,
          e *esa.Esa) bool \{
          mc := e.MatchPref(queryPrefix)
          newStartS := e.Sa[mc.I]
          newCurrLen := mc.L
          *currStartS = newStartS
          *currLen = newCurrLen
          //Add the guaranteed mismatch to the segsite map
          n[newStartS + newCurrLen] = true
          lu := (mc.J == mc.I) && (newCurrLen >= a)
          return lu
\}
\nwused{\\{NW0-17BZZK-1}}\nwendcode{}\nwbegindocs{29}\nwdocspar
We analyze if the match
\begin{itemize}
\itemsep0em
\item starts in the subject after the previous match;
\item is equidistant with the previous match in the subject and
  query;
\item is located on the same strand in the subject as the previous
  match.
\end{itemize}
If these criteria are met, we qualify the current segment as
extendible.
\nwenddocs{}\nwbegincode{30}\sublabel{NW0-3tpl4q-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3tpl4q-1}}}\moddef{Analyze the match~{\nwtagstyle{}\subpageref{NW0-3tpl4q-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-36TQWU-1}}\nwenddeflinemarkup
afterPrev := currStartS > prevEndS
areEquidist := qc - prevEndQ == currStartS - prevEndS
onSameStrand := (currStartS < subjectStrandLen) ==
          (prevStartS < subjectStrandLen)
segCanBeExtended := afterPrev && areEquidist && onSameStrand
\nwused{\\{NW0-36TQWU-1}}\nwendcode{}\nwbegindocs{31}\nwdocspar
We extend the segment to the end of the new anchor and add positions
between the end of the last left anchor and the start right anchor to
the map of mismatches as keys. We also remember that we have just
found a new right anchor.
\nwenddocs{}\nwbegincode{32}\sublabel{NW0-2NrQan-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2NrQan-1}}}\moddef{Extend the current segment~{\nwtagstyle{}\subpageref{NW0-2NrQan-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-36TQWU-1}}\nwenddeflinemarkup
seg.l = seg.l + qc - prevEndQ + currLen
rightAnchorFound = true
\nwused{\\{NW0-36TQWU-1}}\nwendcode{}\nwbegindocs{33}\nwdocspar
To close the current segment is to project it onto the forward strand
(if necessary) and append it to the slice of homologies..
\nwenddocs{}\nwbegincode{34}\sublabel{NW0-SRf1j-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-SRf1j-1}}}\moddef{Close the current segment~{\nwtagstyle{}\subpageref{NW0-SRf1j-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-36TQWU-1}}\nwenddeflinemarkup
if seg.s > subjectStrandLen \{
          seg.s = subjectLen + 1 - seg.s - seg.l
\}
h = append(h, seg)
\nwused{\\{NW0-36TQWU-1}}\nwendcode{}\nwbegindocs{35}\nwdocspar
To open a segment is to declare its start and length, and forget that
the right anchor was found.
\nwenddocs{}\nwbegincode{36}\sublabel{NW0-1pw3Ak-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1pw3Ak-1}}}\moddef{Open a new segment~{\nwtagstyle{}\subpageref{NW0-1pw3Ak-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-36TQWU-1}}\nwenddeflinemarkup
seg.s = currStartS
seg.l = currLen
rightAnchorFound = false
\nwused{\\{NW0-36TQWU-1}}\nwendcode{}\nwbegindocs{37}\nwdocspar
We update previous position in the query and the previous match.
\nwenddocs{}\nwbegincode{38}\sublabel{NW0-1myLcY-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1myLcY-1}}}\moddef{Remember the current match~{\nwtagstyle{}\subpageref{NW0-1myLcY-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-36TQWU-1}}\nwenddeflinemarkup
qp = qc
prevLen = currLen
prevStartS = currStartS
\nwused{\\{NW0-36TQWU-1}}\nwendcode{}\nwbegindocs{39}\nwdocspar
We return the output of \ty{FindHomologies()} if the slice of
homologies is not empty. If it is, we notify the user and exit.
\nwenddocs{}\nwbegincode{40}\sublabel{NW0-WYpU7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-WYpU7-1}}}\moddef{Return the output~{\nwtagstyle{}\subpageref{NW0-WYpU7-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wHDRb-1}}\nwenddeflinemarkup
if len(h) == 0 \{
          fmt.Fprintln(os.Stderr, "No homologous regions found\\n")
          os.Exit(0)
\}
return h, n
\nwused{\\{NW0-2wHDRb-1}}\nwendcode{}\nwbegindocs{41}\nwdocspar
\subsubsection{\ty{ReduceOverlaps()}}
\textbf{\ty{ReduceOverlaps()} accepts a sorted slice of segments}
(homologies) and returns a slice of segments, which contains the
longest chain of non-overlapping homologies.

If \texttt{h} contains less than two elements, we return
early. Otherwise, we reduce overlapping stacks of homologies to the
longest chain of co-linear non-overlapping homologies using the
algorithm for two-dimensional fragment chaining. We start with
initializing variables, then we calculate chain scores, find links of
the longest chain through backtracking, and return the chain.
\nwenddocs{}\nwbegincode{42}\sublabel{NW0-1rkFhS-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1rkFhS-1}}}\moddef{ReduceOverlaps~{\nwtagstyle{}\subpageref{NW0-1rkFhS-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1byJZg-1}}\nwenddeflinemarkup
func ReduceOverlaps(h []Seg) []Seg \{
          hlen := len(h)
          if hlen < 2 \{
                  return h
          \}
          \LA{}Initialize chaining~{\nwtagstyle{}\subpageref{NW0-qdpVZ-1}}\RA{}
          \LA{}Calculate chain score~{\nwtagstyle{}\subpageref{NW0-1aCsJN-1}}\RA{}
          \LA{}Backtrack the chain~{\nwtagstyle{}\subpageref{NW0-1igtIK-1}}\RA{}
          \LA{}Return the chain~{\nwtagstyle{}\subpageref{NW0-nzVJt-1}}\RA{}
\}
\nwused{\\{NW0-1byJZg-1}}\nwendcode{}\nwbegindocs{43}\nwdocspar
We declare variables describing the chain. For each homology \ty{i} we
initialize:
\begin{itemize}
\itemsep0em
\item \ty{predecessor}---the previous homology in the longest chain
  ending before \ty{i});
\item \ty{score}---the length of the longest chain ending at
  \ty{i}. The initial score of the chain is the first
  homology's length;
\item \ty{visited}---whether \ty{i} was visited in backtracking of
  chain links.
\end{itemize}
We also initialize the first elements for \ty{score} and
\ty{predecessor}.
\nwenddocs{}\nwbegincode{44}\sublabel{NW0-qdpVZ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-qdpVZ-1}}}\moddef{Initialize chaining~{\nwtagstyle{}\subpageref{NW0-qdpVZ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1rkFhS-1}}\nwenddeflinemarkup
predecessor := make([]int, hlen)
score := make([]int, hlen)
visited := make([]bool, hlen)
score[0] = h[0].l
predecessor[0] = -1
\nwused{\\{NW0-1rkFhS-1}}\nwendcode{}\nwbegindocs{45}\nwdocspar
We calculate the chain score to maximize the number of non-overlapping
segments in \ty{h}. Starting from the second homology \ty{h[1]}, we
traverse each homology \ty{h[i]} in the sequence. For each \ty{h[i]},
we find the preceding homology \ty{h[k]} that can form the longest
chain ending before \ty{h[i]} starts, ensuring no overlap.
\nwenddocs{}\nwbegincode{46}\sublabel{NW0-1aCsJN-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1aCsJN-1}}}\moddef{Calculate chain score~{\nwtagstyle{}\subpageref{NW0-1aCsJN-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1rkFhS-1}}\nwenddeflinemarkup
for i := 1; i < hlen; i++ \{
          maxScore := 0
          maxIndex := -1
          for k := 0; k < i; k++ \{
                  if h[k].End() < h[i].s \{
                          if score[k] > maxScore \{
                                  maxScore = score[k]
                                  maxIndex = k
                          \}
                  \}
          \}
          predecessor[i] = maxIndex
          if maxIndex != -1 \{
              score[i] = h[i].l + score[maxIndex]
          \} else \{
              score[i] = h[i].l
          \}
\}

// Debug messages. Will be removed in the future
//fmt.Println("***Homologies:")
//for _, el := range(h) \{
//      fmt.Printf("***(%d, %d)\\n", el.s, el.End())
//\}
//fmt.Println("***Scores:", score)
\nwused{\\{NW0-1rkFhS-1}}\nwendcode{}\nwbegindocs{47}\nwdocspar
Now that we have scores for all homologies, we can find \ty{s}, the
index of an element of \texttt{h} with the highest score. This element
is the final link of the chain we are looking for, and its score is
the total score of it. To find \ty{s}, we use the function
\ty{argmaxMapInt()}, which we still have to write. Then we backtrack
through the predecessor links and mark visited homologies.

Now that we have calculated the scores for all homologies, we need to
find \ty{s}, the index of the homology in \texttt{h} with the highest
score. This homology represents the final link in the chain we are
looking for, and its score reflects the total score of the chain. To
find \ty{s}, we use the function \ty{argmax()}, which we still have to
write. After identifying \ty{s}, we backtrack through the
\ty{predecessor} links to trace the entire chain and mark the
corresponding homologies as visited.
\nwenddocs{}\nwbegincode{48}\sublabel{NW0-1igtIK-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1igtIK-1}}}\moddef{Backtrack the chain~{\nwtagstyle{}\subpageref{NW0-1igtIK-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1rkFhS-1}}\nwenddeflinemarkup
s := argmax(score)
for s != -1 \{
          visited[s] = true
          s = predecessor[s]
\}
\nwused{\\{NW0-1rkFhS-1}}\nwendcode{}\nwbegindocs{49}\nwdocspar
The function \ty{argmax()} returns the index of the maximum value in
the input slice of integers.
\nwenddocs{}\nwbegincode{50}\sublabel{NW0-1byJZg-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1byJZg-3}}}\moddef{Functions~{\nwtagstyle{}\subpageref{NW0-1byJZg-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-17BZZK-1}}\nwprevnextdefs{NW0-1byJZg-2}{NW0-1byJZg-4}\nwenddeflinemarkup
func argmax(x []int) int \{
    maxIdx := 0
    for i := 1; i < len(x); i++ \{
          if x[i] > x[maxIdx] \{
              maxIdx = i
          \}
    \}
    return maxIdx
\}
\nwused{\\{NW0-17BZZK-1}}\nwendcode{}\nwbegindocs{51}\nwdocspar
We extract only visited elements of \ty{h} and return the reduced
slice.
\nwenddocs{}\nwbegincode{52}\sublabel{NW0-nzVJt-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-nzVJt-1}}}\moddef{Return the chain~{\nwtagstyle{}\subpageref{NW0-nzVJt-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1rkFhS-1}}\nwenddeflinemarkup
var hred []Seg
for i := 0; i < len(h); i++ \{
          if visited[i] \{
                  hred = append(hred, h[i])
          \}
\}
return hred
\nwused{\\{NW0-1rkFhS-1}}\nwendcode{}\nwbegindocs{53}\nwdocspar
\textbf{\ty(TotalSegLen()) accepts a slice of segments and returns their}
\textbf{total length.}
\nwenddocs{}\nwbegincode{54}\sublabel{NW0-2soqhP-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2soqhP-1}}}\moddef{TotalSegLen~{\nwtagstyle{}\subpageref{NW0-2soqhP-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1byJZg-1}}\nwenddeflinemarkup
func TotalSegLen(segments []Seg) int \{
          sumlen := 0
          for _, s := range(segments) \{
                  sumlen += s.l
          \}
          return sumlen
\}
\nwused{\\{NW0-1byJZg-1}}\nwendcode{}\nwbegindocs{55}\nwdocspar
\subsubsection{\ty{PrintSegSiteRanges()}}
\textbf{\ty{PrintSegSiteRanges()} accepts a bool map of Ns (segregation}
\textbf{sites), a pointer to an output file, and prints their coordinate}
\textbf{ranges.}
\nwenddocs{}\nwbegincode{56}\sublabel{NW0-3lf804-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3lf804-1}}}\moddef{PrintSegSiteRanges~{\nwtagstyle{}\subpageref{NW0-3lf804-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1byJZg-1}}\nwenddeflinemarkup
func PrintSegsiteRanges(m map[int]bool, file *os.File) \{
          if len(m) == 0 \{
                  fmt.Fprintf(file, "No segregation sites found\\n")
          \} else \{
                  k := append([]int\{-1\}, getSortedIntKeys(m)...)
                  k = append(k, -1)
                  for i := 1; i < len(k) - 1; i++ \{
                          prev := k[i] == k[i-1]+1
                          next := k[i] == k[i+1]-1
                          if prev && next \{
                                  continue
                          \}
                          if next \{
                                  fmt.Fprintf(file, "[%d", k[i]+1)
                          \} else if prev \{
                                  fmt.Fprintf(file, ":%d] ", k[i]+1)
                          \} else \{
                                  fmt.Fprintf(file, "%d ", k[i]+1)
                          \}
                  \}
                  fmt.Fprintf(file, "\\n")
          \}
\}
\nwused{\\{NW0-1byJZg-1}}\nwendcode{}\nwbegindocs{57}\nwdocspar
We import \ty{os} and \ty{fmt}.
\nwenddocs{}\nwbegincode{58}\sublabel{NW0-YwBeo-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-YwBeo-4}}}\moddef{Imports~{\nwtagstyle{}\subpageref{NW0-YwBeo-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-17BZZK-1}}\nwprevnextdefs{NW0-YwBeo-3}{\relax}\nwenddeflinemarkup
"os"
"fmt"
\nwused{\\{NW0-17BZZK-1}}\nwendcode{}\nwbegindocs{59}\nwdocspar
We define \ty{getSortedKeys()}.
\nwenddocs{}\nwbegincode{60}\sublabel{NW0-1byJZg-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1byJZg-4}}}\moddef{Functions~{\nwtagstyle{}\subpageref{NW0-1byJZg-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-17BZZK-1}}\nwprevnextdefs{NW0-1byJZg-3}{\relax}\nwenddeflinemarkup
func getSortedIntKeys(m map[int]bool) []int \{
          keys := make([]int, 0, len(m))
          for k, _ := range m \{
                  keys = append(keys, k)
          \}
          sort.Ints(keys)
          return keys
\}
\nwused{\\{NW0-17BZZK-1}}\nwendcode{}\nwbegindocs{61}\nwdocspar
\subsubsection{\ty{SegToFasta()}}
\textbf{\ty{SegToFasta()} converts a slice of segments into actual fasta}
\textbf{sequences. It accepts a slice of segments, a pointer to the}
\textbf{corresponding ESA, and a map of Ns. It returns a slice of pointers to}
\textbf{fasta entries (type fasta.Sequence).}
\nwenddocs{}\nwbegincode{62}\sublabel{NW0-1oxqmx-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1oxqmx-1}}}\moddef{SegToFasta~{\nwtagstyle{}\subpageref{NW0-1oxqmx-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1byJZg-1}}\nwenddeflinemarkup
func SegToFasta(segments []Seg,
          e *esa.Esa,
          n map[int]bool) []*fasta.Sequence \{
          var segfasta []*fasta.Sequence
          for i, s := range(segments) \{
                  start := s.s
                  end := s.End()
                  var data []byte
                  for j := start; j < end + 1; j++ \{
                          if n[j] \{
                                  data = append(data, 'N')
                          \} else \{
                                  data = append(data, e.T[j])
                          \}
                  \}
          segname := fmt.Sprintf("Segment_%d (%d..%d)", i+1, start+1, end + 1)
          converted := fasta.NewSequence(segname, data)
          segfasta = append(segfasta, converted)                
          \}
          return segfasta
\}
\nwused{\\{NW0-1byJZg-1}}\nwendcode{}

\nwixlogsorted{c}{{Analyze the match}{NW0-3tpl4q-1}{\nwixu{NW0-36TQWU-1}\nwixd{NW0-3tpl4q-1}}}%
\nwixlogsorted{c}{{Anchor search}{NW0-36TQWU-1}{\nwixu{NW0-2wHDRb-1}\nwixd{NW0-36TQWU-1}}}%
\nwixlogsorted{c}{{ancs.go}{NW0-17BZZK-1}{\nwixd{NW0-17BZZK-1}}}%
\nwixlogsorted{c}{{Backtrack the chain}{NW0-1igtIK-1}{\nwixu{NW0-1rkFhS-1}\nwixd{NW0-1igtIK-1}}}%
\nwixlogsorted{c}{{Calculate chain score}{NW0-1aCsJN-1}{\nwixu{NW0-1rkFhS-1}\nwixd{NW0-1aCsJN-1}}}%
\nwixlogsorted{c}{{Close the current segment}{NW0-SRf1j-1}{\nwixu{NW0-36TQWU-1}\nwixd{NW0-SRf1j-1}}}%
\nwixlogsorted{c}{{Data structures}{NW0-O2mca-1}{\nwixu{NW0-17BZZK-1}\nwixd{NW0-O2mca-1}}}%
\nwixlogsorted{c}{{Extend the current segment}{NW0-2NrQan-1}{\nwixu{NW0-36TQWU-1}\nwixd{NW0-2NrQan-1}}}%
\nwixlogsorted{c}{{FindHomologies}{NW0-2wHDRb-1}{\nwixu{NW0-1byJZg-1}\nwixd{NW0-2wHDRb-1}}}%
\nwixlogsorted{c}{{Functions}{NW0-1byJZg-1}{\nwixu{NW0-17BZZK-1}\nwixd{NW0-1byJZg-1}\nwixd{NW0-1byJZg-2}\nwixd{NW0-1byJZg-3}\nwixd{NW0-1byJZg-4}}}%
\nwixlogsorted{c}{{Imports}{NW0-YwBeo-1}{\nwixu{NW0-17BZZK-1}\nwixd{NW0-YwBeo-1}\nwixd{NW0-YwBeo-2}\nwixd{NW0-YwBeo-3}\nwixd{NW0-YwBeo-4}}}%
\nwixlogsorted{c}{{Initialize chaining}{NW0-qdpVZ-1}{\nwixu{NW0-1rkFhS-1}\nwixd{NW0-qdpVZ-1}}}%
\nwixlogsorted{c}{{Initialize search}{NW0-4Uv9uh-1}{\nwixu{NW0-2wHDRb-1}\nwixd{NW0-4Uv9uh-1}}}%
\nwixlogsorted{c}{{Methods}{NW0-4RRI1d-1}{\nwixu{NW0-17BZZK-1}\nwixd{NW0-4RRI1d-1}\nwixd{NW0-4RRI1d-2}}}%
\nwixlogsorted{c}{{MinAncLen}{NW0-2JjXVq-1}{\nwixu{NW0-1byJZg-1}\nwixd{NW0-2JjXVq-1}}}%
\nwixlogsorted{c}{{Open a new segment}{NW0-1pw3Ak-1}{\nwixu{NW0-36TQWU-1}\nwixd{NW0-1pw3Ak-1}}}%
\nwixlogsorted{c}{{PrintSegSiteRanges}{NW0-3lf804-1}{\nwixu{NW0-1byJZg-1}\nwixd{NW0-3lf804-1}}}%
\nwixlogsorted{c}{{ReduceOverlaps}{NW0-1rkFhS-1}{\nwixu{NW0-1byJZg-1}\nwixd{NW0-1rkFhS-1}}}%
\nwixlogsorted{c}{{Remember the current match}{NW0-1myLcY-1}{\nwixu{NW0-36TQWU-1}\nwixd{NW0-1myLcY-1}}}%
\nwixlogsorted{c}{{Return the chain}{NW0-nzVJt-1}{\nwixu{NW0-1rkFhS-1}\nwixd{NW0-nzVJt-1}}}%
\nwixlogsorted{c}{{Return the output}{NW0-WYpU7-1}{\nwixu{NW0-2wHDRb-1}\nwixd{NW0-WYpU7-1}}}%
\nwixlogsorted{c}{{SegToFasta}{NW0-1oxqmx-1}{\nwixu{NW0-1byJZg-1}\nwixd{NW0-1oxqmx-1}}}%
\nwixlogsorted{c}{{SortByStart}{NW0-2i99Nb-1}{\nwixu{NW0-1byJZg-1}\nwixd{NW0-2i99Nb-1}}}%
\nwixlogsorted{c}{{TotalSegLen}{NW0-2soqhP-1}{\nwixu{NW0-1byJZg-1}\nwixd{NW0-2soqhP-1}}}%

