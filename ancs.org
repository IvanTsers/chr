#+begin_export latex
\section{Implementation}
Package \ty{ancs} provides functions for finding anchors and
processing homologies.
#+end_export
#+begin_src go <<ancs.go>>=
  package ancs
  import (
	  //<<Imports>>
  )
  //<<Data structures>>
  //<<Methods>>
  //<<Functions>>
#+end_src
#+begin_export latex
\subsection{Data structure \ty{Seg}}
We declare a custom data type \ty{Seg} for storing segments of the
forward strand of the subject. A segment has a start \ty{s} and a
length \ty{l}.
#+end_export
#+begin_src go <<Data structures>>=
  type Seg struct {
	  s int
	  l int
  }
#+end_src
#+begin_export latex
\subsection{Methods}
\subsubsection{\ty{End()}}
Method \ty{End()} returns an end of a segment.
#+end_export
#+begin_src go <<Methods>>=
  func (seg *Seg) End() int {
	  return seg.s + seg.l - 1
  }
#+end_src
#+begin_export latex
\subsubsection{\ty{NewSeg()}}
Constructor method \ty{NewSeg()} returns an empty segment.
#+end_export
#+begin_src go <<Methods>>=
  func NewSeg() Seg {
	  return Seg{s:0, l:0}
  }
#+end_src
#+begin_export latex
\subsection{Functions}
The \ty{ancs} package contains a number of functions.
#+end_export
#+begin_src go <<Functions>>=
  //<<SortByStart>>
  //<<MinAncLen>>
  //<<FindHomologies>>
  //<<ReduceOverlaps>>
  //<<TotalSegLen>>
  //<<PrintSegSiteRanges>>
  //<<SegToFasta>>
#+end_src
#+begin_export latex
\subsubsection{\ty{SortByStart()}}
!\ty{SortByStart()} accepts a slice of segments \ty{s} and sorts the
!segments by their start positions in ascending order.
#+end_export
#+begin_src go <<SortByStart>>=
  func SortByStart(s []Seg) []Seg {
          sort.Slice(s, func(i, j int) bool {
                  return s[i].s < s[j].s
          })
          return s
  }
#+end_src
#+begin_export latex
We import \ty{sort}.
#+end_export
#+begin_src go <<Imports>>=
  "sort"
#+end_src
#+begin_export latex
\subsubsection{\ty{MinAncLen()}}
An anchor is a unique non-random match. Its non-randomness is defined
by its length. The threshold length, or the minimum anchor length, is
found from the null shustring length distribution for a sequence with
given length and GC content.

!The function \ty{MinAncLen()} accepts length, GC content of a
!sequence, and the threshold probability, and calculates the minimum
!anchor length.
#+end_export
#+begin_src go <<MinAncLen>>=
  func MinAncLen(l int, g float64, t float64) int {
	  x := 1
	  cq := 0.0 
	  for cq < t {
		  x++
		  cq = cq + sus.Prob(l, g, x)
	  }
	  return x
  }
#+end_src
#+begin_export latex
We import \ty{sus}.
#+end_export
#+begin_src go <<Imports>>=
  "github.com/evolbioinf/sus"
#+end_src
#+begin_export latex
\subsubsection{\ty{FindHomologies()}}
!The function \ty{FindHomologies()} accepts a \ty{fasta} query
!sequence, an enhanced suffix array and length of the subject sequence,
!and the minimum anchor length \ty{a}. The function returns a slice of
!segments (homologies) and a bool map of segregation sites.

We initialize variables to operate with in the search of homologies,
conduct the search, and return its results.
#+end_export
#+begin_src go <<FindHomologies>>=
  func FindHomologies(
	  query *fasta.Sequence,
	  e *esa.Esa,
	  subjectLen int,
	  a int) ([]Seg, map[int]bool) {
	  //<<Initialize search>>
	  //<<Anchor search>>
	  //<<Return the output>>
  }
#+end_src
#+begin_export latex
We import \ty{fasta} and \ty{esa}.
#+end_export
#+begin_src go <<Imports>>=
  "github.com/ivantsers/fasta"
  "github.com/evolbioinf/esa"
#+end_src
#+begin_export latex
We declare variables to operate with during the search. These are:
\begin{itemize}
  \itemsep0em
  \item current and previous positions in the query;
  \item current match: its length and start in the subject;
  \item previous match: its length, start and end the subject;
  \item current segment;
  \item a slice of segments to store the output in;
  \item a map to store positions of segregation sites (mismatches);
  \item an indicator of right anchor;
  \item length of a \ty{single strand} of the subject;
  \item length of the query.
\end{itemize}

As one might notice, we calculate the full subject's length before
calling \ty{FindHomologies()}, and we calculate the query's length
inside the function. This design is intentional, so the same subject
can be compared to multiple queries.
#+end_export
#+begin_src go <<Initialize search>>=
  var qc, qp int
  var currLen, currStartS int
  var prevLen, prevStartS, prevEndS int
  var seg Seg
  var h []Seg
  n := make(map[int]bool)
  rightAnchorFound := false
  subjectStrandLen := subjectLen/2
  queryLen := query.Length()
#+end_src
#+begin_export latex
We perform anchor search for each prefix in our query. We get a prefix
that starts at the current position and ends at the last byte of the
query. Then we search for a long unique match using the function
\ty{anchorLongMatch()}, which we still have to write.

If such a match is found, we proceed with calculating the end
positions of the previous match in the query and the subject. Then we
analyze the current match and decide, whether the current segment can
be extended with it. If yes, we extend the current segment. If it
cannot be extended and the right anchor is found, we open a new
segment and save the current one in \ty{h}. After these operations, we
remember the current match and jump in the query by at least one
nucleotide (a guaranteed mismatch) before proceeding with the next
prefix.
#+end_export
#+begin_src go <<Anchor search>>=
  for qc < queryLen {
	  queryPrefix := query.Data()[qc:queryLen]
	  if anchorLongMatch(&currStartS, &currLen,
		  n, a, queryPrefix, e) {
		  prevEndQ := qp + prevLen
		  prevEndS = prevStartS + prevLen
		  //<<Analyze the match>>
		  if segCanBeExtended {
		  //<<Extend the current segment>>
		  } else {
			  if rightAnchorFound || prevLen / 2 >= a {
				  //<<Close the current segment>>
			  }
			  //<<Open a new segment>>
		  }
		  //<<Remember the current match>>
	  }
	  qc = qc + currLen + 1
	  fmt.Println()
  }
  //Close the last segment if open:
  if rightAnchorFound || prevLen / 2 >= a {
	  if seg.s > subjectStrandLen {
		  seg.s = subjectLen + 1 - seg.s - seg.l
	  }
	  h = append(h, seg)
  }

#+end_src
#+begin_export latex
!The function \ty{anchorLongMatch()} accepts pointers to length of the
current match and its start in the subject, a map of segregation
sites, minimum anchor length, current query prefix, and a pointer to
the subject ESA. The function returns a boolean and updates the start
and the length of the current match.

A match is unique if it starts and ends at the same position in an
ESA. In terms of a suffix tree, a unique match ends on a leaf.
#+end_export
#+begin_src go <<Functions>>=
  func anchorLongMatch(
	  currStartS, currLen *int,
	  n map[int]bool,
	  a int,
	  queryPrefix []byte,
	  e *esa.Esa) bool {
	  mc := e.MatchPref(queryPrefix)
	  newStartS := e.Sa[mc.I]
	  newCurrLen := mc.L
	  *currStartS = newStartS
	  *currLen = newCurrLen
	  //Add the guaranteed mismatch to the segsite map
	  n[newStartS + newCurrLen] = true
	  lu := (mc.J == mc.I) && (newCurrLen >= a)
	  return lu
  }
#+end_src
#+begin_export latex
We analyze if the match
\begin{itemize}
  \itemsep0em
  \item starts in the subject after the previous match;
  \item is equidistant with the previous match in the subject and
    query;
  \item is located on the same strand in the subject as the previous
    match.
\end{itemize}
If these criteria are met, we qualify the current segment as
extendible.
#+end_export
#+begin_src go <<Analyze the match>>=
  afterPrev := currStartS > prevEndS
  areEquidist := qc - prevEndQ == currStartS - prevEndS
  onSameStrand := (currStartS < subjectStrandLen) ==
	  (prevStartS < subjectStrandLen)
  segCanBeExtended := afterPrev && areEquidist && onSameStrand
#+end_src
#+begin_export latex
We extend the segment to the end of the new anchor and add positions
between the end of the last left anchor and the start right anchor to
the map of mismatches as keys. We also remember that we have just
found a new right anchor.
#+end_export
#+begin_src go <<Extend the current segment>>=
  seg.l = seg.l + qc - prevEndQ + currLen
  rightAnchorFound = true
#+end_src
#+begin_export latex
To close the current segment is to project it onto the forward strand
(if necessary) and append it to the slice of homologies..
#+end_export
#+begin_src go <<Close the current segment>>=
  if seg.s > subjectStrandLen {
	  seg.s = subjectLen + 1 - seg.s - seg.l
  }
  h = append(h, seg)
#+end_src
#+begin_export latex
To open a segment is to declare its start and length, and forget that
the right anchor was found.
#+end_export
#+begin_src go <<Open a new segment>>=
  seg.s = currStartS
  seg.l = currLen
  rightAnchorFound = false
#+end_src
#+begin_export latex
We update previous position in the query and the previous match.
#+end_export
#+begin_src go <<Remember the current match>>=
  qp = qc
  prevLen = currLen
  prevStartS = currStartS
#+end_src
#+begin_export latex
We return the output of \ty{FindHomologies()} if the slice of
homologies is not empty. If it is, we notify the user and exit.
#+end_export
#+begin_src go <<Return the output>>=
  if len(h) == 0 {
	  fmt.Fprintln(os.Stderr, "No homologous regions found\n")
	  os.Exit(0)
  }
  return h, n
#+end_src
#+begin_export latex
\subsubsection{\ty{ReduceOverlaps()}}
!\ty{ReduceOverlaps()} accepts a sorted slice of segments
(homologies) and returns a slice of segments, which contains the
longest chain of non-overlapping homologies.

If \texttt{h} contains less than two elements, we return
early. Otherwise, we reduce overlapping stacks of homologies to the
longest chain of co-linear non-overlapping homologies using the
algorithm for two-dimensional fragment chaining. We start with
initializing variables, then we calculate chain scores, find links of
the longest chain through backtracking, and return the chain.
#+end_export
#+begin_src go <<ReduceOverlaps>>=
  func ReduceOverlaps(h []Seg) []Seg {
	  hlen := len(h)
	  if hlen < 2 {
		  return h
	  }
	  //<<Initialize chaining>>
	  //<<Calculate chain score>>
	  //<<Backtrack the chain>>
	  //<<Return the chain>>
  }
#+end_src
#+begin_export latex
We declare variables describing the chain. For each homology \ty{i} we
initialize:
\begin{itemize}
  \itemsep0em
  \item \ty{predecessor}---the previous homology in the longest chain
    ending before \ty{i});
  \item \ty{score}---the length of the longest chain ending at
    \ty{i}. The initial score of the chain is the first
    homology's length;
  \item \ty{visited}---whether \ty{i} was visited in backtracking of
    chain links.
\end{itemize}
We also initialize the first elements for \ty{score} and
\ty{predecessor}.
#+end_export
#+begin_src go <<Initialize chaining>>=
  predecessor := make([]int, hlen)
  score := make([]int, hlen)
  visited := make([]bool, hlen)
  score[0] = h[0].l
  predecessor[0] = -1
#+end_src
#+begin_export latex
We calculate the chain score to maximize the number of non-overlapping
segments in \ty{h}. Starting from the second homology \ty{h[1]}, we
traverse each homology \ty{h[i]} in the sequence. For each \ty{h[i]},
we find the preceding homology \ty{h[k]} that can form the longest
chain ending before \ty{h[i]} starts, ensuring no overlap.
#+end_export
#+begin_src go <<Calculate chain score>>=
  for i := 1; i < hlen; i++ {
	  maxScore := 0
	  maxIndex := -1
	  for k := 0; k < i; k++ {
		  if h[k].End() < h[i].s {
			  if score[k] > maxScore {
				  maxScore = score[k]
				  maxIndex = k
			  }
		  }
	  }
	  predecessor[i] = maxIndex
	  if maxIndex != -1 {
	      score[i] = h[i].l + score[maxIndex]
	  } else {
	      score[i] = h[i].l
	  }
  }

  // Debug messages. Will be removed in the future
  //fmt.Println("***Homologies:")
  //for _, el := range(h) {
  //	fmt.Printf("***(%d, %d)\n", el.s, el.End())
  //}
  //fmt.Println("***Scores:", score)
#+end_src
#+begin_export latex
Now that we have scores for all homologies, we can find \ty{s}, the
index of an element of \texttt{h} with the highest score. This element
is the final link of the chain we are looking for, and its score is
the total score of it. To find \ty{s}, we use the function
\ty{argmaxMapInt()}, which we still have to write. Then we backtrack
through the predecessor links and mark visited homologies.

Now that we have calculated the scores for all homologies, we need to
find \ty{s}, the index of the homology in \texttt{h} with the highest
score. This homology represents the final link in the chain we are
looking for, and its score reflects the total score of the chain. To
find \ty{s}, we use the function \ty{argmax()}, which we still have to
write. After identifying \ty{s}, we backtrack through the
\ty{predecessor} links to trace the entire chain and mark the
corresponding homologies as visited.
#+end_export
#+begin_src go <<Backtrack the chain>>=
  s := argmax(score)
  for s != -1 {
	  visited[s] = true
	  s = predecessor[s]
  }
#+end_src
#+begin_export latex
The function \ty{argmax()} returns the index of the maximum value in
the input slice of integers.
#+end_export
#+begin_src go <<Functions>>=
  func argmax(x []int) int {
      maxIdx := 0
      for i := 1; i < len(x); i++ {
	  if x[i] > x[maxIdx] {
	      maxIdx = i
	  }
      }
      return maxIdx
  }
#+end_src
#+begin_export latex
We extract only visited elements of \ty{h} and return the reduced
slice.
#+end_export
#+begin_src go <<Return the chain>>=
  var hred []Seg
  for i := 0; i < len(h); i++ {
	  if visited[i] {
		  hred = append(hred, h[i])
	  }
  }
  return hred
#+end_src
#+begin_export latex
!\ty(TotalSegLen()) accepts a slice of segments and returns their
!total length.
#+end_export
#+begin_src go <<TotalSegLen>>=
  func TotalSegLen(segments []Seg) int {
	  sumlen := 0
	  for _, s := range(segments) {
		  sumlen += s.l
	  }
	  return sumlen
  }
#+end_src
#+begin_export latex
\subsubsection{\ty{PrintSegSiteRanges()}}
!\ty{PrintSegSiteRanges()} accepts a bool map of Ns (segregation
!sites), a pointer to an output file, and prints their coordinate
!ranges.
#+end_export
#+begin_src go <<PrintSegSiteRanges>>=
  func PrintSegsiteRanges(m map[int]bool, file *os.File) {
	  if len(m) == 0 {
		  fmt.Fprintf(file, "No segregation sites found\n")
	  } else {
		  k := append([]int{-1}, getSortedIntKeys(m)...)
		  k = append(k, -1)
		  for i := 1; i < len(k) - 1; i++ {
			  prev := k[i] == k[i-1]+1
			  next := k[i] == k[i+1]-1
			  if prev && next {
				  continue
			  }
			  if next {
				  fmt.Fprintf(file, "[%d", k[i]+1)
			  } else if prev {
				  fmt.Fprintf(file, ":%d] ", k[i]+1)
			  } else {
				  fmt.Fprintf(file, "%d ", k[i]+1)
			  }
		  }
		  fmt.Fprintf(file, "\n")
	  }
  }
#+end_src
#+begin_export latex
We import \ty{os} and \ty{fmt}.
#+end_export
#+begin_src go <<Imports>>=
  "os"
  "fmt"
#+end_src
#+begin_export latex
We define \ty{getSortedKeys()}.
#+end_export
#+begin_src go <<Functions>>=
  func getSortedIntKeys(m map[int]bool) []int {
	  keys := make([]int, 0, len(m))
	  for k, _ := range m {
		  keys = append(keys, k)
	  }
	  sort.Ints(keys)
	  return keys
  }
#+end_src
#+begin_export latex
\subsubsection{\ty{SegToFasta()}}
!\ty{SegToFasta()} converts a slice of segments into actual fasta
!sequences. It accepts a slice of segments, a pointer to the
!corresponding ESA, and a map of Ns. It returns a slice of pointers to
!fasta entries (type fasta.Sequence).
#+end_export
#+begin_src go <<SegToFasta>>=
  func SegToFasta(segments []Seg,
	  e *esa.Esa,
	  n map[int]bool) []*fasta.Sequence {
	  var segfasta []*fasta.Sequence
	  for i, s := range(segments) {
		  start := s.s
		  end := s.End()
		  var data []byte
		  for j := start; j < end + 1; j++ {
			  if n[j] {
				  data = append(data, 'N')
			  } else {
				  data = append(data, e.T[j])
			  }
		  }
	  segname := fmt.Sprintf("Segment_%d (%d..%d)", i+1, start+1, end + 1)
	  converted := fasta.NewSequence(segname, data)
	  segfasta = append(segfasta, converted)		
	  }
	  return segfasta
  }
#+end_src
